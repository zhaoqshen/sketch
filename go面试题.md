面试题
tau

1. 什么是中间件？============================中间件是属于可复用软件的范畴，位于操作系统、数据库、网络层之上，应用软件层以下。相当于一种联系上下层的中间介质。
2. 读写锁和互斥锁的区别是什么？============================读写锁在执行读写操作时要额外的表达自己的读写意图。读者之间不互斥，而写者与读写者之间均为互斥关系。简单的说，加读锁锁写；加写锁锁读锁写。读写锁可以通过两个自旋锁或者互斥锁来实现。
3. 自旋锁和互斥锁的区别是什么？===========================自旋锁和互斥锁都是用来保证线程安全的手段。其中自旋锁通过不间断尝试获取锁直到成功来实现，一般用于上锁时间比较短的情况；互斥锁在获取锁失败后，就会立即放弃CPU时间片，同时挂起线程，保存上下文，直到锁被释放被操作系统通知。
4. 阐述一下go的并发模型？===========================go通过语言级别实现了协程调度，更轻量的协程会使得它的性能更加优越，体现在避免了操作系统级别的线程调度需要的内核态切换以及上下文的保存及恢复。goroutine并发模型里面主要有三个模块，MPG。其中M代表物理线程，程序实际执行的单位。P代表CPU的一个核心，分配时间片和寄存器等资源。G代表goroutine，类似进程控制块，保存栈、状态、函数等信息。每个P会维护一个goroutine队列，整个调度系统也会维护一个goroutine队列。每个goroutine执行的时间片结束后，如果任务没有完成，会像操作系统调度一样，会将这个任务迁移到队列的最后。为了避免M的空闲，当一个P的任务队列为空，它会从公共goroutine队列，别的P对应的goroutine队列中取没有执行完的goroutine。
5. redis 的分布式锁如何实现？===========================分布式锁的实现需要保证其原子性操作，一般通过 set xxxxxx nx 即可实现基本的分布式锁。为了避免长期加锁资源不得释放，一般会指定px设置过期时间。为了保证解锁方一定是加锁方，一般key指定一个特殊值，value设置为requestid，为了能删除会变动的key，需要使用redis-lua脚本同时做删除和校验工作。
6. 什么场景用到了kafka？============================kafka是一个分布式、可划分的、冗余备份的持久性的发布-订阅消息系统。使用kafka可以达到缓冲、削峰的作用，上游突发的高并发，下游可能支撑不住，使用kafka可以让他们按照自己的节奏处理；同时如果项目开始的时候不确定后续会接什么需求，可以使用kafka进行解耦；kafka可以实现一对多的方式，一个生产者的消息供好几个消费端使用；消息队列可以堆积请求，后续操作意外终止的情况，也不会丢失数据；有些业务也不需要立即处理，使用kafka能达到异步通信的效果。
7. kafka的broker是干什么的？============================broker是消息的代理，生产者向broker里面的指定topic写信息，消费者从broker的指定topic拉取数据，相当于是消息的中转站。
8. kafka中的zookeeper有什么作用？可以不用么？============================zookeeper是一个分布式的协调组件，早期会将消费者的消费状态、offset的值等存放在zookeeper中，后面的新版本逐渐弱化了zookeeper的依赖，但是broker依然依赖zookeeper，如选举、确认存活等。
9. kafka为什么那么快？============================kafka采用磁盘顺序读写数据，它的速度会远远快过随机读写数据。另外kafka的数据不是即时写入硬盘，它利用了分页存储利用内存提高io效率，类似于虚拟内存的存在，加快了io读写的速度。
10. kafka 的消费组是什么概念？============================是kafka实现单播和广播的两种消息模型的手段。同一个topic的数据会广播给不同的group，同一个group中的worker，只有一个worker能拿到其中的数据。即对于同一个topic，每个group都可以拿到同一个消息，每个worker只能有一个被消费。
11. kafka的消息是否会丢失和重复消费？============================当设置不进行消息成功确认，且发生网络异常或缓冲区溢出；只确认leader消息成功，且leader确认后宕机的情况，会丢失数据。kafka消费有高级和低级两种消费接口，低级接口自己维护offset可以完全控制；高级接口消费的时候，如果提交了新的offset值还没来得及消费，消费者自己挂掉了，就会丢失。针对消息丢失，需要将确认机制设置成-1，即leader和follower均确认接受成功。针对重复消费，可以使用redis过滤。
12. 你们是怎么调用内部服务？=============================当前比较多的调用是api层通过grpc调用微服务；微服务间通过grpc相互调用，同时会进行mysql，redis，三方请求的操作。
13. redis 的 mutli 命令是做什么的？=============================redis事务的开启，类似mysql的begin；对应redis事务的结束是exec，类似mysql的commit。但是不同于mysql，redis的事务并不具有原子性，所以 只可以理解成一批命令的打包。
14. 信号量和互斥量的关系和区别？=============================信号量用户线程的同步，而互斥量用于线程的互斥。同步一般是指在互斥的基础上，通过同步机制达到对资源的有序访问。互斥量的加锁解锁需要由同一个线程实现；信号量则不需要。
15. 一次完整的Web请求包含哪些过程？=============================从用户在浏览器中输入开始，浏览器会先读取内部的缓存，然后根据dns缓存找到需要请求的服务器ip，如果dns缓存中没有，需要从域名解析开始获取对应的公网ip。大型网站为了确保延迟最低，一般会在多区域提供服务，域名会解析到延迟最低的ip。获取到公网ip后，开始建立TCP连接，然后发起HTTP请求，通过nginx或openresty的反向代理将请求发送给对应的HTTP服务，由于HTTP服务部署在k8s管理的docker集群中，这一步会由k8s自动选择对应的pod。被选中的HTTP服务会通过consul/etcd发现微服务，并通过自动的负载均衡将请求打到某一个节点上。如果节点需要操作数据库或者redis，只读一般会在从节点或主节点中选择一个库读；如果是写操作，一般会操作主节点后异步同步到从节点。这些操作结束后，会将返回值反向一步步地返回到浏览器。浏览器会判断是否还会有静态资源需要被加载，如果有，可能会重新发起HTTP请求，这一步可能会涉及到使用cdn缓存。HTTP请求发送完毕后，会四次挥手关闭TCP连接。
16. OSI七层模型包含了哪几层？Redis操作属于哪一层？============================ 应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。应用层：HTTP，FTP；表示层：JEPG，ASCII；会话层：本地与远程主机的会话；传输层：TCP，UDP；网络层：IPV4，IPV6；数据链路层：逻辑连接，硬件寻址等；物理层：建立、维护、断开物理连接。
17.  MySQL的索引有哪几种？索引的数据结构有哪几种？Innodb采用的数据结构是哪个？Innodb采用该种数据结构的原因是什么？什么是聚簇索引？什么是覆盖索引？一张含有索引的数据表最适合存放的数据数量是多少？为什么？=============================索引是一种能提升查询性能的特殊数据结构。MySQL的索引分为普通索引和唯一索引，区别是唯一索引在一张表中只能出现一次，其中主键也属于唯一索引的一种。索引使用的数据结构主要是hash和B+树，其中innodb默认使用的是B+树。hash数据结构适合做等值查询，由于B+树天然的有序性，因此采用B+树会适合做范围查询，包括做order排序的时候，也会命中索引。而且采用hash数据结构将会不支持最左匹配规则，且如果存在大量重复的键，会导致hash碰撞的问题。在mysql中，innodb采用的是聚簇索引，myisam采用的是非聚簇索引。非聚簇索引的索引文件和数据文件是分开的，命中索引后获得索数据所在的位置后获取数据。聚簇索引的数据和索引在同一个文件中，查询过程中找到了索引即找到了数据。反映在数据结构中，聚簇索引的B+树的叶子节点既保存了索引，也保存了数据；非聚簇索引的叶子节点只保存了索引，但是会包含指向对应的数据块指针。innodb的二级索引指向了对主键的引用，即查询的时候命中二级索引后会获取主键查询指定字段。如果需要查询的刚好是主键id，则没有第二步的操作，称为覆盖索引；同理，如果是命中了组合索引中的一个字段同时获取另一个字段，也属于覆盖索引查询。含有innodb的数据表最适合的数据量是1000W条，因为这样B+树的高度还是3，io次数不会有明显的变化。
18.  MySQL的锁有哪几种？分别用于哪些场景？==========================MySQL的锁主要分为行级锁和表级锁，均是悲观锁。表级锁会整表锁住，开销小，速度快，但是并发支持比较差；行级锁会锁住某一行数据进行读写操作，开销大，加锁慢，会出现锁；但是锁的粒度最小，并发支持较好。
19.  MySQL 的事务隔离级别有哪几种？InnoDB使用的事务隔离级别是哪一个？==========================未提交读；提交读；可重复读；可串行化。1.会导致别的事务看到数据更新，造成脏读；2.完全提交前的更改，别的事务是看不到的，但是如果某一事务失败后会回滚，读取的跟第一次不一样；3.解决不可重复读问题，但是解决不了幻读问题，如果事务操作的是某一个范围内的数据，别行数据的插入就会导致幻读；4.强行串行执行，效率最低。Innodb采用可重复读隔离级别。innodb通过在每行记录中保存两个隐含列实现mvcc（多版本控制），一个保存创建时间，一个保存过期时间。每开启一个新事务就会更新版本号。select操作只查找早于当前事务版本的数据，过期版本要么没有要么后于当前版本；insert会更新创建时间；delete会更新过期版本；update会在原数据更新过期数据，并新建一条新纪录新建记录。
20. etcd和consul和zookeeper的联系和区别是什么？============================
feature	consul	zookeeper	etcd
健康检查	服务状态，内存硬盘记录	长连接，keeplive	连接心跳
多数据中心	支持	-	-
kv存储	支持	支持	支持
一致性算法	raft	paxos	raft
cap	ca	cp	cp
接口协议	http dns	客户端	http grpc
watch	全量支持	支持	支持long polling
自身监控	metrics	-	metrics
安全	acl https	acl	https

21. Golang的map是如何实现的？如何扩容的？===========================hash值低位确定bucket的位置，高位匹配tophash数组的列表，如果高位值也相等则取匹配key。通过运算 键数/bucket 数即负载因子大于 6.5 判断是否需要扩容。扩容的过程是渐进式的，即新建一个2xsize的map，读到老数据的情况下，迁移到新map中。
22. Golang的slice创建过程？Golang的slice是如何实现的？如何扩容的？===========================slice根据array创建的情况，slice继承array的后续空间，slice第一个元素的地址与array指定位置的地址是一样的。当length达到cap的时候，会将新建一个2x容量的slice（当大于1024时变为1.25X）
23. Golang的map是不是线程安全的？如何保证其线程安全？如果数据量比较大，如何实现？===========================不是线程安全的。Go1.9之前采用 map+mutex 实现并发安全；之后可以采用内置的 sync Map方法实现。针对比较大的map，可以采用分段锁的设计避免锁的阻塞开销，可以提高读写效率。用外面再套一层hash算法实现分段锁。
24. Golang的GC是如何实现的？Golang的GC与Java的GC有何区别？=============================扫描根对象，启动stw，开启写屏障，开始收集内存中的根对象，全局变量及stack中的变量；标记颜色；重新扫描重新标记，对应因第二步导致的根对象变化；清扫对象。整个gc需要两次stw，1.8以后取消了第一步，1.9以后大幅减少第三步。由于go的gc是和普通goroutine并行的，因此gc扫描的时候可能会改变对象依赖树，第三步rescan会将整个变动过程中的白色对象重新扫描，确认无误后进行清清理。Go的gc是和普通goroutine并行的，需要rescan；Java的gc一定会导致stw，会导致程序不连贯运行。
25. 什么是tcp沾包？什么时候需要处理TCP沾包问题？如何处理沾包现象？=============================1.当发送数据时，由于tcp协议的nagle算法，会将较小内容拼成较大内容一次性发送到服务器，造成沾包；2.当内容较大，服务器的buffersize较小，不能一次性收到所有的内容，第二次请求到达时，接受的内容还是上次没有接受完的内容。可以通过调整buffer大小、设置特殊的结束符、告知服务器包的大小解决。
26. 举例说明有多少种排序算法？快速排序实现原理？对排序实现原理？他们的时间和空间复杂度分别是多少？他们是稳定排序的么？============================ https://github.com/TauWu/backend_learning_notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F.md
27. HTTP 2.0 和 HTTP 1.0 和 HTTP 1.1 的区别？HTTP和HTTPS的区别？HTTP2.0 的多路复用和HTTP1.1的长连接复用有什么区别？=============================HTTP1.1相对于1.0添加了长连接，即一个tcp连接上可以传送多个HTTP请求和响应，避免了HTTP1.0每次请求都要建立tcp链接的开销。HTTP2.0相对于HTTP1.1，将长连接改为了多路复用，多次HTTP请求不再是串行而是并行发送给服务器，减少io等待的时间。HTTPS需要收费证书；http建立在tcp上，数据没有加密，https建立在ssl/tls上，传输内容加密；端口不一样；防止运营商劫持。
28. Go里面什么数据在堆上，什么数据在栈上？=============================go编译器自行决定变量分配在堆或者栈上。每个go版本的逃逸分析是不一样的。
29. redis缓存雪崩发生在什么时候？如何解决？redis缓存击穿发生在什么时候？如何解决？=============================在缓存大面积失效的时候缓存雪崩，可以设置随机的过期时间或者设置缓存的缓存避免大流量打到db；被恶意访问不存在的key，可以缓存本身为空的key，或者配置过滤器过滤非法请求的方式解决。
30. 什么是hash算法？一致性hash算法是什么？一致性hash算法的好处有哪些？一致性hash算法会被用在什么地方？==============================散列算法，计算结果一个key对应一个值，查询时间复杂度为O1。一致性hash算法是为了热点数据分片处理提出的，它将整个数据集想象成一个环，运算结果往前数遇到的第一台机器就是存放数据的目标。一致性hash算法可以避免数据倾斜，迁移数据时候影响机器的数量也会比较少。一般会被用在redis mysql分库的时候。
31. tcp三次握手包含哪几步？tcp四次挥手包含哪几步？=============================1.客户端发syn包给服务端，进入syn_send状态；2.服务端发送syn+ack包给服务端，服务端进入syn_recv状态；3.客户端收到SYN+ACK包，向服务器发送ACK包，连接建立。1.客户端发送FIN，客户端进入FIN_WAIT_1状态；2.服务端收到FIN后，发送一个ACK给客户端，服务端进入close_wait状态；3.服务端发送一个FIN，关闭数据传输服务端进入LAST_ACK；4.客户端收到FIN，客户端进入time_wait，发送一个ACK给服务端，服务端收到，状态改为close。
32. redis有哪五种基础数据类型？分别用于什么场景？===========================string，hash，set，list，zset。
33. 线程、进程、协程的关系和区别是什么？什么是用户态？什么是内核态？如何从用户态切换到内核态？=========================== 进程指的是运行中的程序，它的内部包含了程序和堆栈中的数据，是资源分配的最小单位。线程是任务调度和执行的最小单位。每个进程都有自己独立的代码和数据空间，程序之间的切换有很大的开销；线程可以看成轻量级的进程，一类线程共享代码和堆数据，每个线程拥有自己的独立栈和程序计数器，线程之间切换需要的开销较小。整个操作系统能运行几个进程；同一个进程中允许几个线程同时运行，但是通过CPU调度每个时间片只会执行一个线程。协程是由程序员自己控制、选择线程池中的某个线程来实现的调度单位，它被称为轻量级的线程，可以避免无意义的系统调度，因此可以提高性能，goroutine 其实就是一个协程。
34. 什么是tidb？tidb的构造和应用场景是什么？==============================tidb是一个分布式的newsql。它支持水平弹性扩展，ACID事务，标准SQL，MySQL语法和MySQL协议，具有数据强一致性和高可用性。tidb集群主要分为三个组件，tidb server负责接收sql请求，处理sql相关逻辑，通过pd找到存储计算所需数据的tikv地址；pdserver主要存储了集群的原信息，调度及负载均衡，分配事务id；tikv server负责存储数据，tikv采用raft做数据的一致性和容灾算法。 
35. Tcp四次挥手timewait阶段存在的意义是？线上如果出现大量的timewait，可能产生的原因是什么？==============================存在的意义是：可靠的实现TCP双全工连接的终止；允许老的重复分节在网络中消逝。大量的timewait会阻塞TCP的大量端口。
36. ACID是代指什么？==============================A：原子性；C：一致性；I：隔离性；D：持久性。
37. HTTP协议中304代码存在的意义是什么？==============================自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。这个状态使用了本地的缓存，避免了再次请求网页。
38. 线上服务突然卡顿，你的排查思路？==============================

39 LRU LFU FIFO
一、LRU
LRU全称是Least Recently Used，即最近最久未使用的意思。如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。而用什么数据结构来实现LRU算法呢？

可能大多数人都会想到：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。这种实现思路很简单，但是有什么缺陷呢？需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。

那么有没有更好的实现办法呢？

那就是利用链表移动访问时间的数据顺序和hashmap查询是否是新数据项。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
参考LRU cache

二、LFU
LFU（Least Frequently Used）最近最少使用算法。它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。
注意LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。举个简单的例子：
假设缓存大小为3，数据访问序列为set(2,2),set(1,1),get(2),get(1),get(2),set(3,3),set(4,4)，
则在set(4,4)时对于LFU算法应该淘汰(3,3)，而LRU应该淘汰(1,1)。

为了能够淘汰最少使用的数据，因此LFU算法最简单的一种设计思路就是 利用一个数组存储 数据项，用hashmap存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来的话，在插入数据和访问数据的时候都能达到O(1)的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为O(n)。
参考缓存算法

三、FIFO
FIFO（First in First out），先进先出。其实在操作系统的设计理念中很多地方都利用到了先进先出的思想，比如作业调度（先来先服务），为什么这个原则在很多地方都会用到呢？因为这个原则简单、且符合人们的惯性思维，具备公平性，并且实现起来简单，直接使用数据结构中的队列即可实现。在FIFO Cache设计中，核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。

那么利用什么数据结构来实现呢？

下面提供一种实现思路：利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果Cache存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。在访问数据的时候，如果在Cache中存在该数据的话，则返回对应的value值；否则返回-1。如果想提高访问效率，可以利用hashmap来保存每个key在链表中对应的位置。
参考缓存算法