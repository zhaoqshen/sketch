JVM

1. JVM的垃圾算法有哪几种？默认的垃圾收集器是哪个？CMS收集算法的流程？，stw时机，怎么理解安全点

   ****-Xmx3550m\****

   **-Xms3550m**

   -Xmn 堆内新生代的大小

   -Xss 设置每个线程可使用的内存大小，即栈的大小

   tlab 线程独享

2. Java内存分代模型，GC算法，JVM常见的启动参数；

   主内存--总线---工作内存

   复制-清除

   标记-清理

   标记-清除

3. 什么情况下会出现OOM（堆内存，永久区，堆外区，方法栈）

4. Java内存结构（堆结构，新生代[S0/S1/Elden]，年老代，持久代）新生代回收流程

5. 常用的GC策略算法，什么时候会触发YGC，什么时候触发FGC

   复制

   标记-整理

   标记清除

   创建一个大对象。老年代空间不足（创建大对象年轻代放不下会放到老年代）

   永久代空间不足

   full gc sy.gc 老年代不足。担保机制失败

   

6. 什么是Gc root ，常见的Gc root有哪些

   - 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
   - VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。

   即

   - java虚拟机栈(栈帧中的本地变量表)中的引用的对象。 
   - 方法区中的类静态属性引用的对象。 
   - 方法区中的常量引用的对象。 
   - 本地方法栈中JNI本地方法的引用对象

7. 双亲委派模型。为什么要打破双亲委派模型

8. 

   顶层的ClassLoader无法访问底层ClassLoader所加载的类，此时需要破坏双亲委派模型。jdbc tomcat

   

   

9. cms 与g1的区别

   ![image-20230711153729919](https://wsx666-1302523054.cos.ap-nanjing.myqcloud.com/image/2023-07-11/image-20230711153729919.png)

10. 线上cpu/内存过高怎么查询

11. 直接内存溢出怎么排查

多线程

1. Java中常见的锁，互斥锁，读写锁，信号量，aqs

2. cas 优缺点

3. volatile使用场景，可见性问题的原因,缓存一致性协议,先行发生的具体内容

4. Synchronized 锁升级 过程 。markwold 结构。

   线程在竞争 synchronized 锁时，JVM 首先会检测锁对象的 Mark word 中偏向锁锁标记位是否为 1，锁标记位是否为 01，如果两个条件都满足，则当前锁处于可偏向的状态。
   争抢 synchronized 锁的线程检查锁对象的 Mark Word 中存储的线程 ID 是否是自己的线程 ID ，如果是自己的线程 ID，则表示处于偏向锁状态。当前线程可以,直接进入方法或者代码块执行逻辑。
   如果锁对象的 Mark word 中存储的不是当前线程的 ID，则当前线程会通过 CAS 自旋的方式竞争锁资源。如果成功抢占到锁，则将 Mark Word 中存储的线程 ID 修改为自己的线程 ID ，将偏向锁标记设置为 1，锁标志位设置为 01，当前锁处于偏向锁状态。
   如果当前线程通过 CAS 自旋操作竞争锁失败，则说明此时有其他线程也在争抢锁资源。此时会撤销偏向锁，触发升级为轻量级锁的操作。
   当前线程会根据锁对象的 Mark word 中存储的线程 ID 通知对应的线程暂停，对应的线程会将 Mark Word 的内容置空。
   当前线程与上次获取到锁的线程都会把锁对象的 HashCode 等信息复制到自己的 Displaced Mark Word中，随后两个线程都会执行 CAS 自旋操作，尝试把锁对象的 Mark Word 中的内容修改为指向自己的 Displaced Mark Word 空间来竞争锁。
   竞争锁成功的线程获取到锁，执行方法或代码块中的逻辑。同时，竞争锁成功的线程会将锁对象的 Mark Word 中的锁标志位设置为 00，此时进入轻量级锁状态。
   竞争失败的线程会继续使用 CAS 自旋的方式尝试竞争锁，如果自旋成功竞争到锁，则当前锁仍然处于轻量级锁状态。
   如果线程的 CAS 自旋操作达到一定次数仍未获取到锁，则轻量级锁会膨胀为重量级锁，此时会将镇对锁的 Mark Word 中的锁标志位设置为 10，进人重量级锁状态。
   总之。偏向锁发生于同一时刻只有一个线程竞争锁的场景。如果有多个线程同时竞争锁，则偏向镇会升级为轻量级锁。如果线程的 CAS 自旋操作达到一定次数仍未竞争到锁，则轻量级锁会升级为重量级锁。

5. HashMap数据结构，实现原理。为什么是线程不安全的

6. Java里面的Threadlocal是怎样实现原理。

7. ConcurrentHashMap的实现原理与1.7的区别

8. 线程池原理。工作流程，线程池关闭的流程。

9. 4种限流算法，实现方式

10. 布隆过滤器的数据结构原理

框架

1. Spring中Bean的生命周期。
2. SpringMVC处理请求的流程。
3. Spring AOP解决了什么问题？怎么实现的？aop与cglib，与asm的关系。
4. Spring中BeanFactory和FactoryBean有什么区别？
5. Spring框架中IOC的原理是什么？
6. dubbo spi机制，服务暴露。服务引用。一次完整的请求过程。序列化方式。
7. 各种序列化方式的理解，原理
8. hystrix线程池隔离。信号量隔离好处。实现方式。
9. eureak 服务注册，服务发现。与zk的区别。原理
10. zk选举过程。实现分布式的原理。高并发对读写对zk的影响

数据库相关

1. MySQL InnoDB的特点？
2. redo log 和bin log 的区别？为什么要用2pc
3. 乐观锁和悲观锁的区别？
4. 数据库隔离级别是什么？各种隔离级别的表现，如何解决
5. 索引种类。结构。索引失效的情况。
6. 唯一索引和普通索引的区别，什么是覆盖索引，索引下推。
7. 常用的优化方法。
8. MySQL主备同步的基本原理。
9. 分库分表的实现方式。客户端与服务端实现的两种利弊

Redis

1. Redis 常见的数据结构，

2. redis 为什么这么快，poll,select ,epoll的区别

3. redis 底层的数据结构。跳跃表的实现原理

4. redis 如何实现分布式锁（redssion，自动续期的原理）

5. aof ，rdb差异 ，aof 重写，为什么数据同步使用rdb.

6. Redis 分片的原理，moved ask 指令有什么区别。

7. redis 如何实现乐观锁。

8. redis 如何主从数据同步

9. redis如何保证高可用

10. 缓存击穿。雪崩，穿透。

11. **布隆过滤器判断存在不一定真的存在，但是，判断不存在则一定不存在。**

12. Redis事务的主要作用就是串联多个命令防止别的命令插队。

    Redis事务的主要作用就是串联多个命令防止别的命令插队。**组队中**某个命令出现了报告错误，执行时整个的所有队列都会被取消。

    如果**执行阶段**某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚

    在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务***\*执行之前这个\**\**(\*******\*或这些\**\**) key\**** ***\*被其他命令所改动，那么事务将被打断\****

    取消 WATCH 命令对所有 key 的监视。

    ​	如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了	

    单独的隔离操作
       事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
    没有隔离级别的概念
      队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行
    不保证原子性
      事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

    

消息队列（Rabbit）

1. 4种交换机的类型
2. Rabbit 如何高可用，镜像模式和集群模式的区别
3. 如何保证消息的可靠性
4. 消息积压怎么处理
5. 如何保证消息顺序
6. 什么是死信队列，什么样的消息会进入死信队列。怎么使用死信队列。
   - 消息 TTL 过期（time to live，存活时间，可以用在限时支付消息）
   - 队列达到最大长度（队列满了，无法路由到该队列）
   - 消息被拒绝（ `basic.reject / basic.nack` ），并且 `requeue = false`

解决方案

+ 分布式事务解决
+ mysql，redis数据一致性
+ 高并发解决库存超卖
+ Redis超级热点的数据怎么处理

算法：

链表反转

贪心算法（青蛙上楼梯）

快速排序

冒泡排序