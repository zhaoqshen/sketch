# InnoDB中的事务锁

## 加锁原则

二阶段加锁原则
加锁阶段
解锁阶段
加锁解锁互不相交，各司其职


## 按使用方式分

### 乐观锁

- 先更改值，后判断是否加锁
- 提高并发

### 悲观锁

- 先加锁，后修改值

## 按粒度分

### 表级锁

- InnoDB什么时候对表加S锁？
5.6中在线DDL，已不再加S锁

	- alter table
	- add index

- InnoDB不会对表加X锁
- 意向锁
- 自增自动上锁 / AUTO-INC Locks

### 行级锁

InnoDB执行行级锁的方式是，当它搜索或扫描一个表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁实际上是索引记录锁。


- 共享读锁/s锁
- 排他写锁/x锁
- 插入意向锁
- 间隙锁
- 记录锁/RECORD LOCK
- next-key 锁
- 空间索引的谓词锁

### 页级锁

## 按锁级别分

### 意向锁

- InnoDB支持多粒度锁，允许行锁和表锁共存。
- 意向共享读锁 / IS锁

	- 表示事务打算对表中的各个行设置共享读锁。
	- select *** lock in share mode

	  为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据（比如a,b都拿了锁，a更改了数据，因为b还拿着锁，a提交不了，直到超时），因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。

- 意向排他写锁 / IX锁

	- 表示事务打算对表中的各个行设置排他写锁。
	- select *** for update

	  为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。

- 意向锁协议

	- 事务在获得表中某行上的共享锁之前，必须先获得表上的IS锁或更强的锁。
	- 在事务可以获得表中某一行上的排他锁之前，它必须首先获得表上的IX锁。

- 表级锁类型兼容性

  如果与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突，则不授予该事务。事务将一直等待，直到有冲突的现有锁被释放。如果一个锁请求与一个现有的锁冲突，并且不能被授予，因为这会导致死锁，那么就会发生错误。

  - 写锁必排他
  - 除写锁外，其他同类型的互相兼容
  - 只要是意向锁就兼容
  - 只要是读锁，就兼容

- 怎么看是否加了意向锁

	- SHOW ENGINE INNODB STATUS(开启监控器)
	- TABLE LOCK table `test`.`t` trx id 10080 lock mode IX

- InnoDB——意向锁的作用.md

### 共享读锁 / S锁

- 共享锁允许持有该锁的事务读取一行。
- 多个事务可以持有同一行的s锁
- 只要有一个事务对某一行持有s锁，则其他事务不能对该行申请X锁，直到其他所有S锁释放
- 在获取S锁之前，先获取IS锁或更高级别的锁

### 排他写锁 / X锁

- 独占(X)锁允许持有该锁的事务读取/更新或删除一行。
- 一个事务只要某一行加上了X锁，其他事务不能对该行加锁
- 当事务需要对表加X锁时，先看有没有获得IX锁，其他事务对该表有没有加IX锁
- 获取X锁之前，先获取IX锁

### 记录锁 / RECORD LOCK

- 锁住的是索引记录——索引锁

  单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。
  
  所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。

### 间隙锁 / GAP LOCK

- RR以上
- 作用于索引树，聚簇索引和非聚簇索引中，在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。
- 加锁条件

	- 1 innodb_locks_unsafe_for_binlog参数为0，且sql走的索引为非唯一索引

		- 非唯一索引等值查询，会在该值两侧空隙加GAP锁

	- 2 innodb_locks_unsafe_for_binlog参数为0，且sql是一个范围的当前读操作，这时即使不是非唯一索引也会加gap lock

		- 走索引，且是范围查询时，对空隙加GAP 锁

- 细分

	- 共享间隙锁 / gap S-lock
	- 独占间隙锁 / gap X-lock
	- 两者可以共存，互相兼容

- 唯一作用

	- 防止幻读——阻止特定行数据插入

- 可以禁用掉

	- 回退到RC隔离级别
	- innodb_locks_unsafe_for_binlog 控制(已被废弃)

### 下一键锁 / NEXT-KEY LOCK

- RR以上
- GAP LOCK和RECORD LOCK的结合

	- 非唯一索引等值查询，会在该值两侧空隙加GAP锁 + 该值加record  锁

- 作用

	- 防止幻读——阻止特定行数据插入

### 插入意向锁

- 概念

  插入意向锁是Innodb gap锁的一种类型，这种锁表示要以这样一种方式插入:如果多个事务插入到相同的索引间隙中，如果它们不在间隙中的相同位置插入，则无需等待其他事务。比如说有索引记录4和7，有两个事务想要分别插入5，6，在获取插入行上的独占锁之前，每个锁都使用插入意图锁锁定4和7之间的间隙，但是不要互相阻塞，因为行是不冲突的，意向锁的设计是为了插入的正确和高效。
  
- 例子

- 往一个空隙中插入数据，需要先获得插入意向锁
- 插入意向锁与GAP锁不兼容

### 自增自动上锁 / AUTO-INC Locks

- 自增列的加锁策略

	- 当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。其他session无法在这个表级锁持有时插入任何记录。

## 按操作&加锁方式分

### 按操作

- DDL锁
- DML锁

### 加锁方式

- 自动锁
- 显示锁

## 加锁机制与什么有关？

### 隔离级别

- RC
- RR

	- RR中会出现GAP LOCK和NEXT LOCK保证不会出现幻读

### 是否主键

- 如果是主键，则只需要锁住一行即可，那一行加X锁

### 是否二级索引?是否唯一索引

- 唯一索引只需要锁住索引值record lock + 对应的主键行X lock
- 非唯一索引会锁住索引值 + 附近的空隙 (前面两个合起来 next-key lock) + 对应的主键行X lock  

### 对多列索引来说，版本很重要(ICP)

- 5.6之后支持ICP，在索引中过滤不满足条件的数据，省去一些行的X锁 

### 执行计划是什么？索引扫描还是全表扫描

- 若不走索引，则全表的所有行加锁 + GAP 锁

### 案例，看加的是什么类型的锁

- select * from t1 where id = 10;
- delete from t1 where id = 10;
- delete from t1 where id > 10;

## RR隔离级别下，下列sql加锁情况

### insert into..

- 先获得插入意向锁
- 若插入意向锁不与其他事务冲突，则直接插入
- 假设发生了一个唯一键冲突错误，那么将会在重复的索引记录上加读锁。当有多个session同时插入相同的行记录时，如果另外一个session已经获得该行的排它锁，那么将会导致死锁。

### INSERT ... ON DUPLICATE KEY UPDATE

- 这种sql和insert加锁的不同的是，如果检测到键冲突，它直接申请加排它锁，而不是共享锁。

### 自增id的加锁策略

- 当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。为了访问这个自增的数值，需要加一个表级锁，不过这个表级锁的持续时间只有当前sql，而不是整个事务，即当前sql执行完，该表级锁就释放了。其他session无法在这个表级锁持有时插入任何记录。

### 外键检测的加锁策略

- 如果存在外键约束，任何的insert，update，delete将会检测约束条件，将会在相应的记录上加共享的record lock，无论是否存在外键冲突。

## 死锁

### InnoDB死锁检测

在高并发系统上，当多个线程等待相同的锁时，死锁检测会导致速度变慢。有时，禁用死锁检测并在innodb_lock_wait_timeout 发生死锁时依靠设置进行事务回滚可能会更有效 。可以使用innodb_deadlock_detect 配置选项禁用死锁检测 。

死锁会影响性能，而不是代表严重的错误，因为 死锁会InnoDB自动 检测到死锁条件并回滚受影响的事务之一。

### 如何避免死锁

- 尽量以相同的顺序执行sql
- 加快执行速度，大事务分割成小事务

## 其他

### 查看锁，事务信息show engine innodb status

- 查看行锁信息
show status like 'innodb_row_lock_%';
- 查看表锁
show OPEN TABLES where In_use > 0;
- 开启innodb监控器
SET GLOBAL innodb_status_output=ON;
- 开启innodb锁定监控器
SET GLOBAL innodb_status_output_locks=ON;
- 设置死锁信息输出到错误日志：
set innodb_print_all_deadlocks = on;
- 查看锁等待超时时间：
show variables like 'innodb_lock_wait_timeout';

	- 修改时间：
set @@innodb_lock_wait_timeout=20

- show engine innodb status案例

### 其他参考连接

- 官方参考文档

- 阿里数据库月报

### 其他问题

- 索引上加读锁后，需要对主键行加排他锁，为什么

### MVCC（参考）

- MVCC版本链例子

- 好处

  读不加锁
  读写不冲突

- 读分类

	- 快照读 snapshot read

		- 特征

		  读不加锁
		  读取的是快照
		  快照保存在undo log中的数据链
		  隔离级别不同，快照生成机制不同

		- 类型

			- 简单的读操作

			  select * from table where ?;

	- 当前读 current read

		- 特征

		  读取当前记录最新版本
		  会加锁，保证其他事务不会并发修改该数据

		- 类型

			- 特殊的读操作

				- select * from table where ? lock in share mode;（S锁）
				- select * from table where ? for update;（X锁）

			- 插入/更新/删除操作

				- insert into table values (…);（X锁）
				- update table set ? where ?;（X锁）

					- [图片]2.UPDATE中包含一个当前读

				- delete from table where ?;（X锁）

